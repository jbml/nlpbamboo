= Double Array结构的定义 =

typedef struct {
    int base;
    int check;
} _state_t;

_state_t *_state;


因为base和check的长度是对等的，所以我们把他们放在一个结构体里以便操作。可见Double Array在实现中其实是一个结构体的数组而并非两个数组了。


= 基本操作 =

[当_state容量不够时，我们需要对他进行扩充]
--------------------------------------------------------------------------------
void _inflate(int num)
{
	int neo;

	assert(num > 0);
	neo = (((_header->num + num) >> 12) + 1) << 12; // align for 4096
	_state = (_state_t *)realloc(_state, neo * sizeof(_state_t));
	memset(_state + _header->num, 0, (neo - _header->num) * sizeof(_state_t));
	if (_state == NULL) throw std::bad_alloc();
	_header->num = neo;
}
--------------------------------------------------------------------------------

[base(s) 状态s的base值]
--------------------------------------------------------------------------------
int _base(int s)
{
	assert(s > 0 && s < _header->num);
	return _state[s].base;
}
--------------------------------------------------------------------------------

[check(s) 状态s的check值]
--------------------------------------------------------------------------------
int _check(int s)
{
	assert(s > 0 && s < _header->num);
	return _state[s].check;
}
--------------------------------------------------------------------------------
[next(s, c) 状态s接受输入c后的下一个状态, 该函数只返回状态号并不检测状态是否存在。]
--------------------------------------------------------------------------------
int _next(int s, int ch)
{
	int in = _key2state(ch);

	assert(s > 0 && s < _header->num); 
	if (s + in >= _header->num) _inflate(in);
	return _base(s) + in;
}
--------------------------------------------------------------------------------

[forward(s, c) 同next类似，只是会检查状态是否存在。]
--------------------------------------------------------------------------------
int _forward(int s, int ch)
{
	assert(s > 0 && s < _header->num); 
	int t = _next(s, ch);
	return (t > 0 && t < _header->num && _check(t) == s)?t:0;
}
--------------------------------------------------------------------------------

[_set_base(s) 设置状态s的base值]
--------------------------------------------------------------------------------
void _set_base(int s, int val)
{
	assert(s > 0 && s < _header->num);
	_state[s].base = val;
}
--------------------------------------------------------------------------------

[_set_check(s) 设置状态s的check值]
--------------------------------------------------------------------------------
void _set_check(int s, int val)
{
	assert(s > 0 && s < _header->num);
	_state[s].check = val;
}
--------------------------------------------------------------------------------

由于输入边界值c = '\0'会导致状态跳转错误。因此需要对输入状态进行编码，防止零值的出现。我们需要一对工具函数来完成编码和解码的过程：

[编码]
--------------------------------------------------------------------------------
int _key2state(int ch)
{
	return (unsigned int)ch + 1;
}
--------------------------------------------------------------------------------

[解码]
--------------------------------------------------------------------------------
int _state2key(int s)
{
	assert(s > 0);
	return s - 1;
}
--------------------------------------------------------------------------------



